#include "solver.h"
#include "Functions.h"
#include <iostream>
/*
Справка:

Solver Sol(num_intervals, TEST); - создаём решение (число интервалов сетки, тип задачи)
    Типы задач:
    TEST - тестовая
    MAIN1 - 1 вариант (варианты в пдфке на гугл диске капкаева)
    MAIN2 - 2 вариант
    MAIN3 - 3 вариант
    MAIN4 - 4 вариант
    OSC - осциллирующая 

Какие геттеры нужны для построения
    1 таблицы итерируемся по num_nodes так как это сетка сплайна:
    getA()
    getB()
    getC()
    getD() - это всё для построения коэффициентов (возвращают вектор)
    getX_for_coef_table() - возвращаются узлы (вектор)
    get_n_step() - возвращает шаг, с которым идём по соновной сетке(хз , может и не нужен)

    2 и 3 таблицы : (итерируемся по num_nodes*2 так как это контрольная сетка)
    getX() - возвращаются узлы (вектор)
    getF()
    getDF()
    getD2F()
    getS()
    getDS()
    getD2S() - это всё векторы основной функции и функции сплайна F - основная S - сплайна,
               D и D2 - их производные
    get_N_step() - возвращает шаг, с которым идём по соновной сетке(хз , может и не нужен)

    Справки:
    getF_ERRROR();
    getF_ERRROR_X();
    getDF_ERRROR();
    getDF_ERRROR_X();
    getD2F_ERRROR();
    getD2F_ERRROR_X(); - все возвращают максимальную погрешность и соответсвующий ей x;

*/

int main() {
   
    int num_intervals{ 5 };
    Solver Sol(num_intervals, MAIN1);
    Sol.Solve();
    
    auto f = Sol.getF();
    auto s = Sol.getS();
    //сюда пишется код красивый для вывода таблиц

    return 0;
}